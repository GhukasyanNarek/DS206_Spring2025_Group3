"""
This module provides utility functions for database connection management.

Functions:
----------
- get_connection_string():
    Constructs and returns a database connection string using environment variables.
    The connection string is formatted for use with SQL Server and the pyodbc driver.

    Environment Variables:
    - SQL_SERVER: The hostname or IP address of the SQL Server.
    - SQL_DATABASE: The name of the database to connect to.
    - SQL_USERNAME: The username for database authentication.
    - SQL_PASSWORD: The password for database authentication.
    - SQL_DRIVER: (Optional) The ODBC driver to use. Defaults to "ODBC Driver 17 for SQL Server".

- get_engine():
    Creates and returns a SQLAlchemy engine object using the connection string
    generated by `get_connection_string()`. This engine can be used to interact
    with the database.
"""
import os
from dotenv import load_dotenv
from sqlalchemy import create_engine, text
import time
import pandas as pd
import uuid
from loguru import logger
load_dotenv()

def get_connection_string(database=None):
    server = os.getenv("SQL_SERVER")
    username = os.getenv("SQL_USERNAME")
    password = os.getenv("SQL_PASSWORD")
    driver = os.getenv("SQL_DRIVER", "ODBC Driver 17 for SQL Server")

    if database is None:
        database = os.getenv("SQL_DATABASE")

    return f"mssql+pyodbc://{username}:{password}@{server}:1433/{database}?driver={driver.replace(' ', '+')}"

def get_engine(database=None):
    return create_engine(get_connection_string(database))

def read_sql_file(filepath):
    with open(filepath, 'r') as f:
        return f.read()
    
def wait_until_database_exists(database_name, timeout=10, poll_interval=1):
    engine = get_engine()
    with engine.connect() as conn:
        for i in range(timeout):
            logger.info(f"Checking for database: {database_name} (attempt {i + 1})")
            result = conn.execute(text("SELECT name FROM sys.databases"))
            all_dbs = [row[0] for row in result]
            if database_name in all_dbs:
                logger.info(f"Database {database_name} is available.")
                return True
            time.sleep(poll_interval)
    return False

def safe_date(value):
    try:
        df = pd.to_datetime(value, errors='coerce')
        if pd.isna(df) or df.year <  1753: # SQL Server minimum date as Professor mentioned multiple times
            return None
        return df
    except Exception as e:
        print(f"Error parsing date: {value}, Error: {e}")
        return None
    
def generate_execution_id():
    """Generate a unique UUID for tracking pipeline executions."""
    return str(uuid.uuid4())